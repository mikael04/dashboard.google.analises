---
title: "Análise do banco de dados Dimensions"
output: html_document
---

```{r setup, include=FALSE}
library(dplyr)

## df_dimensions <- toda a base
# df_dimensions <- data.table::fread("buscaCompleta2305.csv")
# fst::write_fst(df_dimensions, "dimensions_compressed", compress = 100)
df_dimensions <- fst::read_fst("dimensions_compressed.fst")
df_dimensions <- tibble::as_tibble(df_dimensions)

df_dimensions_sample <- df_dimensions %>% 
  dplyr::sample_frac(0.1)

## df_dim_sort_alph <- toda a base com campos ordenados em ordem alfabética
df_dim_sort_alph <- df_dimensions %>% 
  dplyr::select(sort(tidyselect::peek_vars()))


df_dim_sort_alph_sample <- df_dimensions_sample %>% 
  dplyr::select(sort(tidyselect::peek_vars()))

## df_dim_cut <- base com campos selecionados (provavelmente nem todos são importantes, esse campo tem 22 variáveis)
## diferente do geral que tem 84
df_dim_cut <- df_dimensions %>%
  dplyr::select(id, year, doi, type, date, date_normal, date_inserted, clinical_trial_ids, altmetrics.score, open_access_categories, open_access_categories_v2, research_org_city_names, research_org_country_names, reference_ids,  title.preferred, abstract.preferred, publisher.name, publisher.name, metrics.times_cited, metrics.recent_citations, citations_count, journal.id, journal.title)
## df_dim_cut <- base com campos selecionados (provavelmente nem todos são importantes, esse campo tem 22 variáveis)
## diferente do geral que tem 84
df_dim_cut_sample <- df_dimensions_sample %>%
  dplyr::select(id, year, doi, type, date, date_normal, date_inserted, clinical_trial_ids, altmetrics.score, open_access_categories, open_access_categories_v2, research_org_city_names, research_org_country_names, reference_ids,  title.preferred, abstract.preferred, publisher.name, publisher.name, metrics.times_cited, metrics.recent_citations, citations_count, journal.id, journal.title)

```

### 1. Indicadores de Impacto

altimetrics.score - ```r sum(is.na(df_dimensions$altmetrics.score)  + is.null(df_dimensions$altmetrics.score))```  de  ```r nrow(df_dimensions)``` linhas em branco (NA, NULL)

clinical_trial_ids - ```r sum(is.na(df_dimensions$clinical_trial_ids)  + is.null(df_dimensions$clinical_trial_ids)) + sum(df_dimensions$clinical_trial_ids == "" )``` de  ```r nrow(df_dimensions)``` linhas em branco (NA, NULL ou "")

times_cited - ```r sum(is.na(df_dimensions$metrics.times_cited)  + is.null(df_dimensions$metrics.times_cited))``` de  ```r nrow(df_dimensions)``` linhas em branco (NA, NULL)

```{r indicadores_impacto, echo = F, eval = F}

############################
####  Altimetria (altimetrics.score)
## Verificar tipo da variável
typeof(df_dimensions$altmetrics.score) #Integer
## Verificar valores faltantes
sum(is.na(df_dimensions$altmetrics.score)  + is.null(df_dimensions$altmetrics.score))
############################

############################
#### Clinical trials id (clinical_trial_ids)
## Verificar tipo da variável 
typeof(df_dimensions$clinical_trial_ids) #character
## Verificar valores faltantes
sum(is.na(df_dimensions$clinical_trial_ids)  + is.null(df_dimensions$clinical_trial_ids)) + sum(df_dimensions$clinical_trial_ids == "" )
############################

############################
#### Vezes citado (times)
## Verificar tipo da variável
typeof(df_dimensions$metrics.times_cited) #Integer
## Verificar valores faltantes
sum(is.na(df_dimensions$metrics.times_cited)  + is.null(df_dimensions$metrics.times_cited))
############################


#df_dimensions_cut_sample <- head(df_dimensions_cut, 50)
```

#### **1.1. Altimetria**
```{r alt_anal_expl, echo=F, eval = TRUE}
skimr::skim(df_dim_cut$altmetrics.score)

plotly::plot_ly(data = df_dim_cut, x = ~altmetrics.score, type = 'histogram')
```



#### **1.2. Clinical trials ids**
```{r clin_anal_expl, echo=F, eval = TRUE}
skimr::skim(df_dim_cut$clinical_trial_ids)
```



#### **1.3. Times cited**
```{r times_cited_anal_expl, echo=F, eval = TRUE}
skimr::skim(df_dim_cut$metrics.times_cited)

plotly::plot_ly(data = df_dim_cut, x = ~metrics.times_cited, type = 'histogram')
```

```{r country_anal_setup, echo = F}
## Recebe apenas a coluna de paises
df_paises <- df_dimensions %>%
  dplyr::select(id, research_org_country_names) %>%
  dplyr::filter(research_org_country_names != "")
paises <- df_paises$research_org_country_names
## Separa em uma lista de mais de um elemento quando possui mais de um país
paises_split <- paises %>%
  stringr::str_split(., ';')
## remove todos os caractéres menos letras e números
#list <- lapply(paises, stringr::str_replace_all, ";", "0")
## Apenas valores únicos, para listar todos os países (sem repetição)
unique_values <- unique(rapply(paises_split, function(x) head(x, 30)))
# 
# ## Transforma em dataframe para manipulação
# dt_list <- purrr::map(paises_split, data.table::as.data.table)
# dt <- data.table::rbindlist(dt_list, fill = TRUE, idcol = T)
# ## Agrupa por país e conta quantas vezes aparece
# dt_count <- dt %>%
#   dplyr::filter(V1 != '' & V1 != ' ') %>%
#   dplyr::group_by(V1) %>%
#   dplyr::summarise(count = n()) %>%
#   dplyr::rename(Paises = V1) %>%
#   dplyr::ungroup()
# 
# dt_count_ordered <- dt_count %>%
#   dplyr::arrange(desc(count))
# 
# 
# # data.table::fwrite(dt_count_ordered, "../data-raw/df_paises_count_ordered.csv")
# # data.table::fwrite(dt_count_ordered, "../data-raw/df_sample_count_ordered.csv")
# 

```


### 2. Filtros laterais

Ano - ```r sum(is.na(df_dimensions$year)  + is.null(df_dimensions$year))```  de  ```r nrow(df_dimensions)``` linhas em branco (NA, NULL)

País - ```r sum(is.na(df_dimensions$research_org_country_names)  + is.null(df_dimensions$research_org_country_names)) + sum(df_dimensions$research_org_country_names == "" )``` de  ```r nrow(df_dimensions)``` linhas em branco (NA, NULL ou "")
Nesse caso, verifica se existe na linha um ou mais países, ou se a linha está vazia.
Para países, temos um total de ```r length(unique_values)``` países aparecendo pelo menos uma vez. E o ranking de países que mais aparecem podem ser vistos abaixo.

Tipo de publicação - ```r sum(is.na(df_dimensions$type)  + is.null(df_dimensions$type))``` de  ```r nrow(df_dimensions)``` linhas em branco (NA, NULL).
Podem ser do tipo: _article, book, chapter, monograph, preprint_ ou _proceeding_

```{r filtro_lateral, echo = F, eval = F}

############################
####  Ano (year)
## Verificar tipo da variável
typeof(df_dimensions$year) # Integer
## Verificar valores faltantes
sum(is.na(df_dimensions$year)  + is.null(df_dimensions$year))
############################

############################
#### Países (reasearch_org_country_names)
## Verificar tipo da variável
typeof(df_dimensions$research_org_country_names) # Character
## Verificar valores faltantes
sum(is.na(df_dimensions$research_org_country_names)  + is.null(df_dimensions$research_org_country_names)) + sum(df_dimensions$research_org_country_names == "" )
############################

############################
#### Tipo de publicação  (type)
## Verificar tipo da variável
typeof(df_dimensions$type) # Character
## Verificar valores faltantes
sum(is.na(df_dimensions$type)  + is.null(df_dimensions$type))
############################


#df_dimensions_cut_sample <- head(df_dimensions_cut, 50)
```

#### **2.1. Ano**
```{r ano_anal_expl, echo=F, eval = TRUE}
skimr::skim(df_dim_cut$year)

plotly::plot_ly(data = df_dim_cut, x = ~year, nbinsx = 2, type = 'histogram')
```

#### **2.2. Países trials ids**
```{r paises_anal_expl, echo=F, eval = TRUE}
# skimr::skim(df_dim_cut$research_org_country_names)
dt_paises_count_ordered <- data.table::fread("df_paises_count_ordered.csv")
dt_paises_count_top20 <- dt_paises_count_ordered %>%
  dplyr::slice_head(n = 20)

## Plot
layout_axis_y <- list(
  title = "",
  showline = F,
  showticklabels = T,
  showgrid = F
)
layout_axis_x <- list(
  title = "",
  showline = F,
  showticklabels = T,
  showgrid = F,
  tickformat = "digit"
) 
p <- plotly::plot_ly(dt_paises_count_top20, type = 'bar', x = ~count, y = ~reorder(Paises, count))
p <- p %>%
  plotly::layout(title = "Publicações por país", xaxis = layout_axis_x, yaxis = layout_axis_y, dragmode='pan') %>%
  plotly::config(modeBarButtonsToRemove = c("zoom2d", "select2d", "lasso2d", "autoScale2d", "toggleSpikelines"), displaylogo = FALSE)
p
# reactable::reactable(dt_count)
# 
# reactable::reactable(dt_count, defaultSortOrder = "asc",
#                      columns = list (
#                        Paises = reactable::colDef(defaultSortOrder = "asc")
#                      ))
```



#### **2.3. Tipo de publicação**
```{r tipo_cited_anal_expl, echo=F, eval = TRUE}
skimr::skim(df_dim_cut$type)
plotly::plot_ly(data = df_dim_cut, x = ~type, type = 'histogram')
```

#### **3. Categorias**
```{r categories, echo=F, eval = TRUE}
df_dim_categories <- df_dimensions %>%
  dplyr::select(id, categories.bra_v1.values, categories.for_v1.first_level.codes, categories.for_v1.second_level.codes, categories.hra_v1.values, categories.hrcs_hc_v1.values, categories.hrcs_rac_v1.codes, categories.icrp_cso_v1.codes, categories.icrp_ct_v1.values, categories.rcdc_v1.values, categories.sdg_v1.codes, categories.uoa_v1.codes, category_bra.values, category_for.first_level.codes, category_for.second_level.codes, category_hra.values, category_hrcs_hc.values, category_hrcs_rac.codes, category_icrp_cso.codes, category_icrp_ct.values, category_rcdc.values, category_sdg.codes, category_uoa.codes)

skimr::skim(df_dim_categories)

df_dim_categories <- df_dim_categories %>%
  dplyr::filter(length(categories.for_v1.first_level.codes) > 2) %>%
  dplyr::select(id, categories.for_v1.first_level.codes) %>%
  dplyr::filter(stringr::str_detect(categories.for_v1.first_level.codes,"[0123456789]"))
#   dplyr::group_by(categories.for_v1.first_level.codes) %>%
#   dplyr::summarise(count = n())
# skimr::skim(df_dim_categories)
# glimpse(df_dim_categories)
# 
# ## Pega apenas a variável que quero para fazer contagem
# categoria <- df_dim_categories$categories.for_v1.first_level.codes #%>%
#   #dplyr::filter(stringr::str_detect(., "[[:digit:]]"))
# list_categ <- lapply(categoria, stringr::str_replace_all, "'", "")
# list_categ <- lapply(list_categ, stringr::str_replace_all, " ", "")
# list_categ <- lapply(list_categ, stringr::str_replace_all, "\\[", "")
# list_categ <- lapply(list_categ, stringr::str_replace_all, "\\]", "")
# #list_categ <- lapply(df_dim_categories, stringr::str_replace_all, "\\[", "")
# ## Separa em uma lista de mais de um elemento quando possui mais de um país
# list_categ_split <- list_categ %>%
#   stringr::str_split(., ',')
# 
# ## remove todos os caractéres menos letras e números
# #list_categ <- lapply(paises, stringr::str_replace_all, ";", "0")
# ## Apenas valores únicos, para listar todos os países (sem repetição)
# unique_values <- unique(rapply(list_categ_split, function(x) head(x, 5)))
# 
# ## Transforma em dataframe para manipulação
# dt_list <- purrr::map(list_categ_split, data.table::as.data.table)
# dt <- data.table::rbindlist(dt_list, fill = TRUE, idcol = T)
# ## Agrupa por país e conta quantas vezes aparece
# dt_count <- dt %>%
#   dplyr::filter(V1 != '' & V1 != ' ') %>%
#   dplyr::group_by(V1) %>%
#   dplyr::summarise(count = n()) %>%
#   dplyr::rename(Categorias = V1) %>%
#   dplyr::ungroup()
# 
# dt_count_ordered <- dt_count %>%
#   dplyr::arrange(desc(count))

# data.table::fwrite(dt_count_ordered, "../data-raw/df_categ_count_ordered.csv")
df_categ_count <- data.table::fread("df_categ_count_ordered.csv") %>%
  dplyr::rename(ID = Categorias)
df_nome_categ <- data.table::fread("ANZSRC_FoR.csv") %>%
  dplyr::rename(Category = FoR)
df_categ <- dplyr::inner_join(df_categ_count, df_nome_categ, by='ID') %>%
  dplyr::mutate(Category = paste0(ID, " - ", Category)) %>%
  dplyr::select(Category, count) %>%
  dplyr::rename(Count = count)
df_categ_withTotal <- df_categ %>%
  ## Adicionando linha de total
  dplyr::bind_rows(summarise(.,
                      across(where(is.numeric), sum),
                      across(where(is.character), ~"TOTAL")))

library(plotly)
## Plot
layout_axis_y <- list(
  title = "",
  showline = F,
  showticklabels = T,
  showgrid = F
)
layout_axis_x <- list(
  title = "",
  showline = F,
  showticklabels = T,
  showgrid = F,
  tickformat = "digit"
)
m <- list(l=350, r=50, b=50, t=30, pad=4)
p <- plotly::plot_ly(df_categ, x = ~Count, y = ~reorder(Category, Count), type = 'bar')
p <- p %>%
  plotly::layout(title = "Publicações por categoria", xaxis = layout_axis_x, yaxis = layout_axis_y, dragmode='pan', margin = m) %>%
    plotly::config(modeBarButtonsToRemove = c("zoom2d", "select2d", "lasso2d", "autoScale2d", "toggleSpikelines"), displaylogo = FALSE)
p
```

#### **4. Mapas**


```{r mapa_dist, echo=F, eval = TRUE}

# Download the shapefile. (note that I store it in a folder called DATA. You have to change that if needed.)
# download.file("http://thematicmapping.org/downloads/TM_WORLD_BORDERS_SIMPL-0.3.zip" , destfile="world_shape_file.zip")
# You now have it in your current working directory, have a look!

# Unzip this file. You can do it with R (as below), or clicking on the object you downloaded.
# system("world_shape_file.zip")
#  -- > You now have 4 files. One of these files is a .shp file! (TM_WORLD_BORDERS_SIMPL-0.3.shp)
#  
library(rgdal)
world_spdf <- readOGR( 
  dsn= paste0(getwd(),"/world_shape_file/") , 
  layer="TM_WORLD_BORDERS_SIMPL-0.3",
  verbose=FALSE
)

# Library
library(leaflet)
library(sp)

## Lendo df com count de países já em ordem
df_count_ordered <- data.table::fread("df_paises_count_ordered.csv") %>%
  dplyr::rename(NAME = Paises)
## Renomeando colunas de world_spdf (esse dataframe tem todos os países)
country_names <- as.data.frame(world_spdf@data$NAME) %>%
  dplyr::rename(NAME = 'world_spdf@data$NAME')
## Fazendo juncão para adicionar países que não possuem (NA)
df_count_ordered <- right_join(df_count_ordered, country_names, by=c("NAME"))
## Alterando valores de NA para 0
df_count_ordered$count[is.na(df_count_ordered$count)] = 0

## Criando novo SPDF com todos os países e adicionando a coluna "count" para contagem de publicacoes
oo <- sp::merge(world_spdf,df_count_ordered, by="NAME")

## Criando breaks e paleta de cores
mybins <- c(0,100,500,1000,5000,10000,25000,50000, 100000)
mypalette <- colorBin( palette="YlOrBr", domain=oo@data$count, na.color="transparent", bins=mybins)

# Criando texto tooltip
mytext <- paste(
    "Pais: ", oo@data$NAME,"<br/>", 
    "Publicacoes: ", oo@data$count, 
    sep="") %>%
  lapply(htmltools::HTML)

m <- leaflet(oo) %>% 
  addTiles()  %>% 
  setView( lat=10, lng=0 , zoom=2) %>%
  addPolygons( stroke=FALSE ,
               fillOpacity = 0.5, smoothFactor = 0.5,
               fillColor = ~mypalette(count),
               color = "white",
               weight = 0.3,
               label = mytext,
               labelOptions = labelOptions(
                 style = list("font-weight" = "normal", padding = "3px 8px"), 
                 textsize = "13px", 
                 direction = "auto"
               )
  ) %>%
  addLegend( pal=mypalette, values=~count, opacity=0.9, title = "Publicacoes", position = "bottomleft" )

m

```

#### **5. Funders**
Funders - ```r sum(is.na(df_dimensions$funder_orgs)  + is.null(df_dimensions$funder_orgs)) + sum(df_dimensions$funder_orgs == "")```  de  ```r nrow(df_dimensions)``` linhas em branco (NA, NULL)

```{r funders, echo=F, eval = TRUE}
# sum(is.na(df_dimensions$funder_orgs)  + is.null(df_dimensions$funder_orgs)) + sum(df_dimensions$funder_orgs == "")
skimr::skim(df_dimensions$funder_orgs)

```